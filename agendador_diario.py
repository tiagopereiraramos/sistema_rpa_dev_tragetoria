"""
Agendador Di√°rio para RPAs 1 e 2
Sistema de agendamento autom√°tico que roda todos os dias

Desenvolvido em Portugu√™s Brasileiro
"""

import asyncio
import schedule
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, Any
import json
import os

# Configura√ß√£o de logs
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/agendador_rpa.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Importa RPAs 1 e 2 (que rodam diariamente)
try:
    from rpa_coleta_indices import executar_coleta_indices
    from rpa_analise_planilhas import executar_analise_planilhas
except ImportError:
    logger.warning("RPAs n√£o encontrados - usando simula√ß√£o")
    
    async def executar_coleta_indices(planilha_id, credenciais_google=None):
        class MockResult:
            def __init__(self):
                self.sucesso = True
                self.dados = {
                    "ipca": {"valor": 4.62, "fonte": "IBGE"},
                    "igpm": {"valor": 3.89, "fonte": "FGV"}
                }
        return MockResult()
    
    async def executar_analise_planilhas(planilha_calculo_id, planilha_apoio_id, credenciais_google=None):
        class MockResult:
            def __init__(self):
                self.sucesso = True
                self.dados = {
                    "contratos_para_reajuste": 10,
                    "fila_processamento": [
                        {"numero_titulo": "123456", "cliente": "CLIENTE TESTE"}
                    ]
                }
        return MockResult()

class AgendadorRPA:
    """
    Agendador respons√°vel por executar RPAs 1 e 2 diariamente
    e disparar RPAs 3 e 4 quando necess√°rio
    """
    
    def __init__(self):
        self.configuracoes = self._carregar_configuracoes()
        self.historico_execucoes = []
        self.pasta_logs = "logs"
        self._criar_pasta_logs()
        
    def _criar_pasta_logs(self):
        """Cria pasta de logs se n√£o existir"""
        if not os.path.exists(self.pasta_logs):
            os.makedirs(self.pasta_logs)
    
    def _carregar_configuracoes(self) -> Dict[str, Any]:
        """Carrega configura√ß√µes do agendador"""
        return {
            "planilha_calculo_id": os.getenv("PLANILHA_CALCULO_ID", "1f723KXu5_KooZNHiYIB3EettKb-hUsOzDYMg7LNC_hk"),
            "planilha_apoio_id": os.getenv("PLANILHA_APOIO_ID", "1f723KXu5_KooZNHiYIB3EettKb-hUsOzDYMg7LNC_hk"),
            "credenciais_google": "./credentials/google_service_account.json",
            "horario_execucao": "08:00",  # 8h da manh√£
            "timezone": "America/Sao_Paulo",
            "webhook_notificacao": os.getenv("WEBHOOK_NOTIFICACAO", None)
        }
    
    def salvar_execucao(self, resultado: Dict[str, Any]):
        """Salva resultado da execu√ß√£o no hist√≥rico"""
        execucao = {
            "timestamp": datetime.now().isoformat(),
            "resultado": resultado
        }
        
        self.historico_execucoes.append(execucao)
        
        # Salva em arquivo JSON para dashboard
        arquivo_historico = f"{self.pasta_logs}/historico_execucoes.json"
        with open(arquivo_historico, 'w', encoding='utf-8') as f:
            json.dump(self.historico_execucoes[-30:], f, indent=2, ensure_ascii=False)  # √öltimas 30
    
    async def executar_rpas_diarios(self):
        """
        Executa RPAs 1 e 2 diariamente
        """
        logger.info("üöÄ Iniciando execu√ß√£o di√°ria dos RPAs 1 e 2")
        
        resultado_execucao = {
            "data": datetime.now().strftime("%Y-%m-%d"),
            "horario": datetime.now().strftime("%H:%M:%S"),
            "rpa1_coleta_indices": None,
            "rpa2_analise_planilhas": None,
            "fila_gerada": False,
            "contratos_identificados": 0,
            "rpas_34_disparados": False,
            "sucesso_geral": False
        }
        
        try:
            # EXECUTA RPA 1: Coleta de √çndices
            logger.info("üìä Executando RPA 1 - Coleta de √çndices Econ√¥micos")
            
            resultado_rpa1 = await executar_coleta_indices(
                planilha_id=self.configuracoes["planilha_calculo_id"],
                credenciais_google=self.configuracoes["credenciais_google"]
            )
            
            resultado_execucao["rpa1_coleta_indices"] = {
                "sucesso": resultado_rpa1.sucesso,
                "dados": resultado_rpa1.dados if hasattr(resultado_rpa1, 'dados') else {},
                "erro": getattr(resultado_rpa1, 'erro', None)
            }
            
            if resultado_rpa1.sucesso:
                logger.info("‚úÖ RPA 1 conclu√≠do com sucesso")
            else:
                logger.error(f"‚ùå RPA 1 falhou: {getattr(resultado_rpa1, 'erro', 'Erro desconhecido')}")
            
            # EXECUTA RPA 2: An√°lise de Planilhas  
            logger.info("üìã Executando RPA 2 - An√°lise de Planilhas")
            
            resultado_rpa2 = await executar_analise_planilhas(
                planilha_calculo_id=self.configuracoes["planilha_calculo_id"],
                planilha_apoio_id=self.configuracoes["planilha_apoio_id"],
                credenciais_google=self.configuracoes["credenciais_google"]
            )
            
            resultado_execucao["rpa2_analise_planilhas"] = {
                "sucesso": resultado_rpa2.sucesso,
                "dados": resultado_rpa2.dados if hasattr(resultado_rpa2, 'dados') else {},
                "erro": getattr(resultado_rpa2, 'erro', None)
            }
            
            if resultado_rpa2.sucesso:
                logger.info("‚úÖ RPA 2 conclu√≠do com sucesso")
                
                # Verifica se h√° contratos para processar
                dados_rpa2 = getattr(resultado_rpa2, 'dados', {})
                contratos_para_reajuste = dados_rpa2.get('contratos_para_reajuste', 0)
                fila_processamento = dados_rpa2.get('fila_processamento', [])
                
                resultado_execucao["contratos_identificados"] = contratos_para_reajuste
                resultado_execucao["fila_gerada"] = len(fila_processamento) > 0
                
                # DISPARA RPAs 3 e 4 se houver fila
                if fila_processamento:
                    logger.info(f"üéØ {len(fila_processamento)} contratos identificados - Disparando RPAs 3 e 4")
                    await self._disparar_rpas_processamento(fila_processamento, resultado_execucao)
                else:
                    logger.info("‚ÑπÔ∏è Nenhum contrato identificado para reparcelamento hoje")
                    
            else:
                logger.error(f"‚ùå RPA 2 falhou: {getattr(resultado_rpa2, 'erro', 'Erro desconhecido')}")
            
            # Determina sucesso geral
            resultado_execucao["sucesso_geral"] = (
                resultado_execucao["rpa1_coleta_indices"]["sucesso"] and 
                resultado_execucao["rpa2_analise_planilhas"]["sucesso"]
            )
            
        except Exception as e:
            logger.error(f"üí• Erro durante execu√ß√£o di√°ria: {str(e)}")
            resultado_execucao["erro_geral"] = str(e)
        
        # Salva resultado no hist√≥rico
        self.salvar_execucao(resultado_execucao)
        
        # Notifica se configurado
        await self._enviar_notificacao(resultado_execucao)
        
        logger.info("üèÅ Execu√ß√£o di√°ria finalizada")
        return resultado_execucao
    
    async def _disparar_rpas_processamento(self, fila_processamento, resultado_execucao):
        """
        Dispara RPAs 3 e 4 via API para processar a fila
        """
        try:
            import aiohttp
            
            # URL da API local
            api_url = "http://localhost:5000"
            
            async with aiohttp.ClientSession() as session:
                # Dispara workflow dos RPAs 3 e 4 via API
                payload = {
                    "planilha_calculo_id": self.configuracoes["planilha_calculo_id"],
                    "planilha_apoio_id": self.configuracoes["planilha_apoio_id"],
                    "processar_todos": True
                }
                
                async with session.post(f"{api_url}/workflow/reparcelamento", json=payload) as response:
                    if response.status == 200:
                        resultado = await response.json()
                        resultado_execucao["rpas_34_disparados"] = True
                        resultado_execucao["workflow_id"] = resultado.get("dados", {}).get("execucao_id")
                        logger.info(f"‚úÖ RPAs 3 e 4 disparados via API - ID: {resultado_execucao.get('workflow_id')}")
                    else:
                        logger.error(f"‚ùå Falha ao disparar RPAs 3 e 4: {response.status}")
                        
        except ImportError:
            logger.warning("‚ö†Ô∏è aiohttp n√£o dispon√≠vel - simulando disparo dos RPAs 3 e 4")
            resultado_execucao["rpas_34_disparados"] = True
            resultado_execucao["workflow_id"] = "simulated_123"
        except Exception as e:
            logger.error(f"‚ùå Erro ao disparar RPAs 3 e 4: {str(e)}")
    
    async def _enviar_notificacao(self, resultado_execucao):
        """Envia notifica√ß√£o sobre resultado da execu√ß√£o"""
        if not self.configuracoes.get("webhook_notificacao"):
            return
        
        try:
            # Implementar webhook/email/SMS conforme necess√°rio
            logger.info("üìß Notifica√ß√£o enviada")
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar notifica√ß√£o: {str(e)}")
    
    def configurar_agendamento(self):
        """
        Configura agendamento di√°rio dos RPAs
        """
        horario = self.configuracoes["horario_execucao"]
        
        # Agenda execu√ß√£o di√°ria
        schedule.every().day.at(horario).do(
            lambda: asyncio.run(self.executar_rpas_diarios())
        )
        
        logger.info(f"‚è∞ Agendamento configurado para {horario} todos os dias")
        
        # Permite execu√ß√£o manual para teste
        schedule.every().monday.at("09:00").tag("teste_semanal")
    
    def executar_agora(self):
        """Executa RPAs imediatamente (para teste)"""
        logger.info("üîÑ Execu√ß√£o manual iniciada")
        return asyncio.run(self.executar_rpas_diarios())
    
    def iniciar_agendador(self):
        """
        Inicia o loop do agendador
        """
        logger.info("üöÄ Agendador RPA iniciado")
        logger.info(f"üìÖ Pr√≥xima execu√ß√£o: {schedule.next_run()}")
        
        while True:
            schedule.run_pending()
            time.sleep(60)  # Verifica a cada minuto

def main():
    """
    Fun√ß√£o principal do agendador
    """
    print("=" * 80)
    print("‚è∞ AGENDADOR RPA - SISTEMA DE REPARCELAMENTO")
    print("ü§ñ RPAs 1 e 2: Execu√ß√£o di√°ria autom√°tica")
    print("üéØ RPAs 3 e 4: Disparados conforme demanda")
    print("=" * 80)
    
    agendador = AgendadorRPA()
    
    # Configura√ß√µes
    import sys
    if len(sys.argv) > 1:
        comando = sys.argv[1].lower()
        
        if comando == "agora":
            print("‚ñ∂Ô∏è Executando agora...")
            resultado = agendador.executar_agora()
            print(f"‚úÖ Resultado: {resultado['sucesso_geral']}")
            print(f"üìä Contratos identificados: {resultado['contratos_identificados']}")
            
        elif comando == "configurar":
            agendador.configurar_agendamento()
            print("‚öôÔ∏è Agendamento configurado. Use 'python agendador_diario.py iniciar' para come√ßar")
            
        elif comando == "iniciar":
            agendador.configurar_agendamento()
            agendador.iniciar_agendador()
            
        else:
            print("Comandos: agora | configurar | iniciar")
    else:
        print("üîß Uso:")
        print("  python agendador_diario.py agora      # Executa imediatamente")
        print("  python agendador_diario.py configurar # Configura agendamento") 
        print("  python agendador_diario.py iniciar    # Inicia agendador")

if __name__ == "__main__":
    main()